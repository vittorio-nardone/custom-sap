; This file is autogenerated, do not edit.
#once
#ruledef
{
	; Add Memory to Accumulator with Carry (absolute) [Z N C]
	ADC {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x03 @ value
 	} 
	; Add Memory to Accumulator with Carry (absolute - X index) [Z N C O]
	ADC {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x05 @ value
 	} 
	; Add Memory to Accumulator with Carry (absolute - Y index) [Z N C O]
	ADC {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x87 @ value
 	} 
	; Add Register D to Accumulator with Carry [Z N C]
	ADC d => { 
		0x6F
 	} 
	; Add Register E to Accumulator with Carry [Z N C]
	ADC e => { 
		0x06
 	} 
	; Add Memory to Accumulator with Carry (immediate) [Z N C]
	ADC {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0x69 @ value
 	} 
	ADC #{value: u8} => asm { ADC {value} }
	; Add Memory to Accumulator with Carry (zero page) [Z N C]
	ADC {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x6D @ value
 	} 
	; Add Memory to Accumulator with Carry (zero page - X index) [Z N C O]
	ADC {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x04 @ value
 	} 
	; Add Memory to Accumulator with Carry (zero page - Y index) [Z N C O]
	ADC {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x86 @ value
 	} 
	; AND Memory with Accumulator (absolute) [Z N]
	AND {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x08 @ value
 	} 
	; AND Register D with Accumulator [Z N]
	AND d => { 
		0x09
 	} 
	; AND Register E with Accumulator [Z N]
	AND e => { 
		0x0A
 	} 
	; AND Memory with Accumulator (immediate) [Z N]
	AND {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0x29 @ value
 	} 
	AND #{value: u8} => asm { AND {value} }
	; AND Memory with Accumulator (zero page) [Z N]
	AND {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x07 @ value
 	} 
	; Shift Left One Bit (accumulator) [Z N C]
	ASL a => { 
		0xAF
 	} 
	; Branch on Carry Clear (absolute) 
	BCC {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x19 @ value
 	} 
	; Branch on Carry Clear (zero page) 
	BCC {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x90 @ value
 	} 
	; Branch on Carry Set (absolute) 
	BCS {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x22 @ value
 	} 
	; Branch on Carry Set (zero page) 
	BCS {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xB0 @ value
 	} 
	; Branch on Result Zero (absolute) 
	BEQ {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x23 @ value
 	} 
	; Branch on Result Zero (zero page) 
	BEQ {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xF0 @ value
 	} 
	; Test Accumulator BITs with Memory (absolute) [Z N]
	BIT {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x17 @ value
 	} 
	; Test Accumulator BITs with Memory (immediate) [Z N]
	BIT {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0x15 @ value
 	} 
	BIT #{value: u8} => asm { BIT {value} }
	; Test Accumulator BITs with Memory (zero page) [Z N]
	BIT {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x16 @ value
 	} 
	; Branch on Result Minus (absolute) 
	BMI {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x24 @ value
 	} 
	; Branch on Result Minus (zero page) 
	BMI {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x30 @ value
 	} 
	; Branch on Result not Zero (absolute) 
	BNE {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x25 @ value
 	} 
	; Branch on Result not Zero (zero page) 
	BNE {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xD0 @ value
 	} 
	; Branch on Result Plus (absolute) 
	BPL {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x27 @ value
 	} 
	; Branch on Result Plus (zero page) 
	BPL {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x10 @ value
 	} 
	; Jump to interrupt handler routine [I]
	BRK  => { 
		0x00
 	} 
	; Clear Carry Flag [C]
	CLC  => { 
		0x18
 	} 
	; Clear interrupt disable [I]
	CLI  => { 
		0x58
 	} 
	; Compare Memory with Accumulator (absolute) [Z N C]
	CMP {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x42 @ value
 	} 
	; Compare Memory with Accumulator (absolute - X index) [Z N C O]
	CMP {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0xB6 @ value
 	} 
	; Compare Memory with Accumulator (absolute - Y index) [Z N C O]
	CMP {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0xB7 @ value
 	} 
	; Compare Memory with Accumulator (immediate) [Z N C]
	CMP {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xC9 @ value
 	} 
	CMP #{value: u8} => asm { CMP {value} }
	; Compare Memory with Accumulator (zero page) [Z N C]
	CMP {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x5C @ value
 	} 
	; Compare Memory with Accumulator (zero page - X index) [Z N C O]
	CMP {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xB4 @ value
 	} 
	; Compare Memory with Accumulator (zero page - Y index) [Z N C O]
	CMP {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xB5 @ value
 	} 
	; Compare Memory with Register D (absolute) [Z N C]
	CPD {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x44 @ value
 	} 
	; Compare Register E and Register D [Z N C]
	CPD e => { 
		0x51
 	} 
	; Compare Memory with Register D (immediate) [Z N C]
	CPD {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xE5 @ value
 	} 
	CPD #{value: u8} => asm { CPD {value} }
	; Compare Memory with Register D (zero page) [Z N C]
	CPD {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x43 @ value
 	} 
	; Compare Memory with Register E (absolute) [Z N C]
	CPE {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x46 @ value
 	} 
	; Compare Memory with Register E (immediate) [Z N C]
	CPE {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xE4 @ value
 	} 
	CPE #{value: u8} => asm { CPE {value} }
	; Compare Memory with Register E (zero page) [Z N C]
	CPE {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x45 @ value
 	} 
	; Compare Memory with Register X (absolute) [Z N C]
	CPX {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x4A @ value
 	} 
	; Compare Register D and Register X [Z N C]
	CPX d => { 
		0xEB
 	} 
	; Compare Register E and Register X [Z N C]
	CPX e => { 
		0xE2
 	} 
	; Compare Memory and Register X (immediate) [Z N C]
	CPX {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xE0 @ value
 	} 
	CPX #{value: u8} => asm { CPX {value} }
	; Compare Memory with Register X (zero page) [Z N C]
	CPX {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x47 @ value
 	} 
	; Compare Register Y and Register X [Z N C]
	CPX y => { 
		0xE1
 	} 
	; Compare Memory with Register Y (absolute) [Z N C]
	CPY {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x4E @ value
 	} 
	; Compare Register D and Register Y [Z N C]
	CPY d => { 
		0x4F
 	} 
	; Compare Register E and Register Y [Z N C]
	CPY e => { 
		0x50
 	} 
	; Compare Memory and Register Y (immediate) [Z N C]
	CPY {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xE3 @ value
 	} 
	CPY #{value: u8} => asm { CPY {value} }
	; Compare Memory with Register Y (zero page) [Z N C]
	CPY {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x4B @ value
 	} 
	; Decrement Memory by One (absolute) [Z N]
	DEC {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x53 @ value
 	} 
	; Decrement Memory by One (zero page) [Z N]
	DEC {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xCE @ value
 	} 
	; Decrement Register D by One [Z N]
	DED  => { 
		0x28
 	} 
	; Decrement Register E by One [Z N]
	DEE  => { 
		0x2D
 	} 
	; Decrement Register X by One [Z N]
	DEX  => { 
		0xCA
 	} 
	; Decrement Register Y by One [Z N]
	DEY  => { 
		0xCB
 	} 
	; Exclusive-OR Memory with Accumulator (absolute) [Z N]
	EOR {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x12 @ value
 	} 
	; Exclusive-OR Register D with Accumulator [Z N]
	EOR d => { 
		0x13
 	} 
	; Exclusive-OR Register E with Accumulator [Z N]
	EOR e => { 
		0x14
 	} 
	; Exclusive-OR Memory with Accumulator (immediate) [Z N]
	EOR {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0x49 @ value
 	} 
	EOR #{value: u8} => asm { EOR {value} }
	; Exclusive-OR Memory with Accumulator (zero page) [Z N]
	EOR {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x11 @ value
 	} 
	; Freeze CPU 
	HLT  => { 
		0xFF
 	} 
	; Increment Memory by One (absolute) [Z N]
	INC {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x52 @ value
 	} 
	; Increment Memory by One (zero page) [Z N]
	INC {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xEE @ value
 	} 
	; Increment Register D by One [Z N]
	IND  => { 
		0x2E
 	} 
	; Increment Register E by One [Z N]
	INE  => { 
		0x2F
 	} 
	; Increment Register X by One [Z N]
	INX  => { 
		0xE8
 	} 
	; Increment Register Y by One [Z N]
	INY  => { 
		0xC8
 	} 
	; Jump to New Location (absolute) 
	JMP {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x4D @ value
 	} 
	; Jump to New Location (indirect - absolute) 
	JMP ({value: u24}) => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x91 @ value
 	} 
	; Jump to New Location (indirect - zero page) 
	JMP ({value: u16}) => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x8F @ value
 	} 
	; Jump to New Location (zero page) 
	JMP {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x4C @ value
 	} 
	; Jump to New Location Saving Return Address (absolute) 
	JSR {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x21 @ value
 	} 
	; Jump to New Location Saving Return Address (indirect - absolute) 
	JSR ({value: u24}) => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x93 @ value
 	} 
	; Jump to New Location Saving Return Address (indirect - zero page) 
	JSR ({value: u16}) => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x92 @ value @ 0x00
 	} 
	; Jump to New Location Saving Return Address (zero page) 
	JSR {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x20 @ value @ 0x00
 	} 
	; Load Accumulator with Memory (absolute) [Z N]
	LDA {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0xA7 @ value
 	} 
	; Load Accumulator with Memory (absolute - X index) [Z O N]
	LDA {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0xBE @ value
 	} 
	; Load Accumulator with Memory (absolute - Y index) [Z O N]
	LDA {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x32 @ value
 	} 
	; Load Accumulator with Memory (DE pointer - zero page - X index) [Z O N]
	LDA de,x  => { 
		0x94
 	} 
	; Load Accumulator with Memory (immediate) [Z N]
	LDA {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xA9 @ value
 	} 
	LDA #{value: u8} => asm { LDA {value} }
	; Load Accumulator with Memory (zero page) [Z N]
	LDA {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xAD @ value
 	} 
	; Load Accumulator with Memory (zero page - X index) [Z O N]
	LDA {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xBD @ value
 	} 
	; Load Accumulator with Memory (zero page - Y index) [Z O N]
	LDA {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x31 @ value
 	} 
	; Load Accumulator with Memory (YDE pointer - absolute - X index) [Z O N]
	LDA yde,x  => { 
		0xB2
 	} 
	; Load Register D with Memory (absolute) [Z N]
	LDD {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x34 @ value
 	} 
	; Load Register D with Memory (immediate) [Z N]
	LDD {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xA5 @ value
 	} 
	LDD #{value: u8} => asm { LDD {value} }
	; Load Register D with Memory (zero page) [Z N]
	LDD {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x33 @ value
 	} 
	; Load Register E with Memory (absolute) [Z N]
	LDE {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x36 @ value
 	} 
	; Load Register E with Memory (immediate) [Z N]
	LDE {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xA6 @ value
 	} 
	LDE #{value: u8} => asm { LDE {value} }
	; Load Register E with Memory (zero page) [Z N]
	LDE {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x35 @ value
 	} 
	; Load Output with Memory (absolute) 
	LDO {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x41 @ value
 	} 
	; Load Output with Memory (immediate) 
	LDO {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xFE @ value
 	} 
	LDO #{value: u8} => asm { LDO {value} }
	; Load Output with Memory (zero page) 
	LDO {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xFD @ value
 	} 
	; Load Register X with Memory (absolute) [Z N]
	LDX {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0xA4 @ value
 	} 
	; Load Register X with Memory (immediate) [Z N]
	LDX {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xA2 @ value
 	} 
	LDX #{value: u8} => asm { LDX {value} }
	; Load Register X with Memory (zero page) [Z N]
	LDX {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xA3 @ value
 	} 
	; Load Register Y with Memory (absolute) [Z N]
	LDY {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x39 @ value
 	} 
	; Load Register Y with Memory (immediate) [Z N]
	LDY {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xA0 @ value
 	} 
	LDY #{value: u8} => asm { LDY {value} }
	; Load Register Y with Memory (zero page) [Z N]
	LDY {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x37 @ value
 	} 
	; Shift One Bit Right (accumulator) [Z N C]
	LSR a => { 
		0xA8 @ 0x01
 	} 
	; No Operation 
	NOP  => { 
		0xEA
 	} 
	; OR Memory with Accumulator (absolute) [Z N]
	ORA {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x0D @ value
 	} 
	; OR Register D with Accumulator [Z N]
	ORA d => { 
		0x0E
 	} 
	; OR Register E with Accumulator [Z N]
	ORA e => { 
		0x0F
 	} 
	; OR Memory with Accumulator (immediate) [Z N]
	ORA {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0x0B @ value
 	} 
	ORA #{value: u8} => asm { ORA {value} }
	; OR Memory with Accumulator (zero page) [Z N]
	ORA {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x0C @ value
 	} 
	; Push Accumulator on Stack 
	PHA  => { 
		0x48
 	} 
	; Push Register D on Stack 
	PHD  => { 
		0x95
 	} 
	; Push Register E on Stack 
	PHE  => { 
		0x96
 	} 
	; Push Register X on Stack 
	PHX  => { 
		0x97
 	} 
	; Push Register Y on Stack 
	PHY  => { 
		0x98
 	} 
	; Pull Accumulator from Stack [Z N]
	PLA  => { 
		0x68
 	} 
	; Pull Register D from Stack [Z N]
	PLD  => { 
		0x99
 	} 
	; Pull Register E from Stack [Z N]
	PLE  => { 
		0x9A
 	} 
	; Pull Register X from Stack [Z N]
	PLX  => { 
		0x9E
 	} 
	; Pull Register Y from Stack [Z N]
	PLY  => { 
		0x9F
 	} 
	; Rotate One Bit Left (absolute) [Z N C]
	ROL {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x54 @ value
 	} 
	; Rotate One Bit Left (accumulator) [Z N C]
	ROL a => { 
		0x2A
 	} 
	; Rotate Register D One Bit Left [Z N C]
	ROL d => { 
		0x2C
 	} 
	; Rotate Register E One Bit Left [Z N C]
	ROL e => { 
		0x2B
 	} 
	; Rotate One Bit Left (zero page) [Z N C]
	ROL {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x26 @ value
 	} 
	; Rotate One Bit Right (absolute) [Z N C]
	ROR {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x55 @ value @ 0x01
 	} 
	; Rotate One Bit Right (accumulator) [Z N C]
	ROR a => { 
		0x6A @ 0x01
 	} 
	; otate Register D One Bit Right [Z N C]
	ROR d => { 
		0x6C @ 0x01
 	} 
	; Rotate Register E One Bit Right [Z N C]
	ROR e => { 
		0x6B @ 0x01
 	} 
	; Rotate One Bit Right (zero page) [Z N C]
	ROR {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x66 @ value @ 0x01
 	} 
	; Return from Interrupt [I]
	RTI  => { 
		0x40
 	} 
	; Return from Subroutine 
	RTS  => { 
		0x60
 	} 
	; Subtract Memory from Accumulator with Borrow (absolute) [Z N C]
	SBC {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x5B @ value
 	} 
	; Subtract Memory from Accumulator with Borrow (absolute - X index) [Z N C]
	SBC {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x61 @ value
 	} 
	; Subtract Memory from Accumulator with Borrow (absolute - Y index) [Z N C]
	SBC {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x89 @ value
 	} 
	; Subtract Register D from Accumulator with Borrow [Z N C]
	SBC d => { 
		0x5D
 	} 
	; Subtract Register E from Accumulator with Borrow [Z N C]
	SBC e => { 
		0x5E
 	} 
	; Subtract Memory from Accumulator with Borrow (immediate) [Z N C]
	SBC {value: u8} => { 
		assert(value >= 0)
		assert(value <= 0xff)
		0xE9 @ value
 	} 
	SBC #{value: u8} => asm { SBC {value} }
	; Subtract Memory from Accumulator with Borrow (zero page) [Z N C]
	SBC {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0xED @ value
 	} 
	; Subtract Memory from Accumulator with Borrow (zero page - X index) [Z N C]
	SBC {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x5F @ value
 	} 
	; Subtract Memory from Accumulator with Borrow (zero page - Y index) [Z N C]
	SBC {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x88 @ value
 	} 
	; Subtract Register E from Register X with Borrow [Z N C]
	SBX e => { 
		0xEF
 	} 
	; Set clock speed to Fast 
	SCF  => { 
		0x02
 	} 
	; Set clock speed to Slow 
	SCS  => { 
		0x01
 	} 
	; Set Carry Flag [C]
	SEC  => { 
		0x38
 	} 
	; Set interrupt disable [I]
	SEI  => { 
		0x78
 	} 
	; Store Accumulator in Memory (absolute) 
	STA {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x8E @ value
 	} 
	; Store Accumulator in Memory (absolute - X index) [O]
	STA {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x62 @ value
 	} 
	; Store Accumulator in Memory (absolute - Y index) [O]
	STA {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x70 @ value
 	} 
	; Store Accumulator in Memory (DE pointer - zero page - X index) [O]
	STA de,x  => { 
		0xA1
 	} 
	; Store Accumulator in Memory (zero page) 
	STA {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x8D @ value
 	} 
	; Store Accumulator in Memory (zero page - X index) [O]
	STA {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x9D @ value
 	} 
	; Store Accumulator in Memory (zero page - Y index) [O]
	STA {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x6E @ value
 	} 
	; Store Accumulator in Memory (YDE pointer - absolute - X index) [O]
	STA yde,x  => { 
		0xB3
 	} 
	; Store Register D in Memory (absolute) 
	STD {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x7B @ value
 	} 
	; Store Register D in Memory (absolute - X index) [O]
	STD {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x7D @ value
 	} 
	; Store Register D in Memory (absolute - Y index) [O]
	STD {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x7F @ value
 	} 
	; Store Register D in Memory (zero page) 
	STD {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x7A @ value
 	} 
	; Store Register D in Memory (zero page - X index) [O]
	STD {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x7C @ value
 	} 
	; Store Register D in Memory (zero page - Y index) [O]
	STD {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x7E @ value
 	} 
	; Store Register E in Memory (absolute) 
	STE {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x81 @ value
 	} 
	; Store Register E in Memory (absolute - X index) [O]
	STE {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x83 @ value
 	} 
	; Store Register E in Memory (absolute - Y index) [O]
	STE {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x85 @ value
 	} 
	; Store Register E in Memory (zero page) 
	STE {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x80 @ value
 	} 
	; Store Register E in Memory (zero page - X index) [O]
	STE {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x82 @ value
 	} 
	; Store Register E in Memory (zero page - Y index) [O]
	STE {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x84 @ value
 	} 
	; Store Register X in Memory (absolute) 
	STX {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x72 @ value
 	} 
	; Store Register X in Memory (absolute - Y index) [O]
	STX {value: u24},y  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x74 @ value
 	} 
	; Store Register X in Memory (zero page) 
	STX {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x71 @ value
 	} 
	; Store Register X in Memory (zero page - Y index) [O]
	STX {value: u16},y  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x73 @ value
 	} 
	; Store Register Y in Memory (absolute) 
	STY {value: u24} => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x76 @ value
 	} 
	; Store Register Y in Memory (absolute - X index) [O]
	STY {value: u24},x  => { 
		assert(value >= 0x10000)
		assert(value <= 0xffffff)
		0x79 @ value
 	} 
	; Store Register Y in Memory (zero page) 
	STY {value: u16} => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x75 @ value
 	} 
	; Store Register Y in Memory (zero page - X index) [O]
	STY {value: u16},x  => { 
		assert(value >= 0x100)
		assert(value <= 0xffff)
		0x77 @ value
 	} 
	; Transfer Accumulator to Register D [Z N]
	TAD  => { 
		0x56
 	} 
	; Transfer Accumulator to Register E [Z N]
	TAE  => { 
		0x57
 	} 
	; Transfer Accumulator to Interrupt mask register 
	TAI  => { 
		0xAE
 	} 
	; Transfer Accumulator to Output [Z N]
	TAO  => { 
		0xAB
 	} 
	; Transfer Accumulator to Register X [Z N]
	TAX  => { 
		0xAA
 	} 
	; Transfer Accumulator to Register Y [Z N]
	TAY  => { 
		0xBB
 	} 
	; Transfer Register D to Accumulator [Z N]
	TDA  => { 
		0x59
 	} 
	; Transfer Register D to Register X [Z N]
	TDX  => { 
		0x9C
 	} 
	; Transfer Register E to Accumulator [Z N]
	TEA  => { 
		0x5A
 	} 
	; Transfer Register E to Register Y [Z N]
	TEY  => { 
		0x8C
 	} 
	; Transfer Interrupt register to Accumulator [Z N]
	TIA  => { 
		0xAC
 	} 
	; Transfer Register X to Accumulator [Z N]
	TXA  => { 
		0x8A
 	} 
	; Transfer Register X to Register D [Z N]
	TXD  => { 
		0x9B
 	} 
	; Transfer Register Y to Accumulator [Z N]
	TYA  => { 
		0xBA
 	} 
	; Transfer Register Y to Register E [Z N]
	TYE  => { 
		0x8B
 	} 
}

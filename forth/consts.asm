#once

; **********************************************************
; THE STARTING ADDRESS OF THE FORTH MEMORY
#const F_MEMORY_START = 0xB000
; THE MAX SIZE OF A SINGLE INPUT (64 bytes -> up to 256)
#const F_MAX_INPUT_SIZE = 0x40
; THE MAX SIZE OF THE STACK
#const F_MAX_STACK_SIZE = 0x100
; THE MAX SIZE OF THE DICTIONARY (built-in + user)
#const F_MAX_DICT_SIZE = 0x1000 ; 4K
; THE MAX SIZE OF THE STATUS SAVE AREA
#const F_MAX_STATUS_SIZE = 0x400 ; 1K
; THE MAX SIZE OF THE DO-LOOP STACK AREA
#const F_MAX_DO_LOOP_SIZE = 0x100 ; 256 byte
; THE MAX SIZE OF THE BEGIN-UNTIL STACK AREA
#const F_MAX_BEGIN_UNTIL_SIZE = 0x100 ; 256 byte
; THE MAX SIZE OF THE IF-THEN STACK AREA
#const F_MAX_IF_THEN_SIZE = 0x100 ; 256 byte
; **********************************************************

; **********************************************************
; MEMORY OFFSETS
#const F_USER_INPUT_BUFFER_START = F_MEMORY_START + 0x0000
#const F_USER_INPUT_BUFFER_END = F_MEMORY_START + 0x00FF

#const F_INPUT_BUFFER_COUNT = F_MEMORY_START + 0x0100
#const F_TOKEN_START = F_MEMORY_START + 0x0101
#const F_TOKEN_COUNT = F_MEMORY_START + 0x0102
#const F_TOKEN_VALUE= F_MEMORY_START + 0x0103
#const F_STACK_COUNT = F_MEMORY_START + 0x0104

#const F_DICT_ADD_BUFFER_START = F_MEMORY_START + 0x0105
#const F_DICT_ADD_BUFFER_END = F_MEMORY_START + 0x011A

#const F_DICT_USER_LAST_ADD_LSB = F_MEMORY_START + 0x011B
#const F_DICT_USER_LAST_ADD_MSB = F_MEMORY_START + 0x011C

; #const FREE = F_MEMORY_START + 0x011D
; #const FREE = F_MEMORY_START + 0x011E

#const F_DICT_EXEC_BUILT_IN_PTR_PAGE = F_MEMORY_START + 0x011F
#const F_DICT_EXEC_BUILT_IN_PTR_MSB  = F_MEMORY_START + 0x0120
#const F_DICT_EXEC_BUILT_IN_PTR_LSB  = F_MEMORY_START + 0x0121

#const F_EXIT_INTERPRETER_FLAG = F_MEMORY_START + 0x0122
#const F_EXECUTION_ERROR_FLAG = F_MEMORY_START + 0x0123
#const F_EXECUTION_ABORT_FLAG = F_MEMORY_START + 0x0124

#const F_DICT_ADD_USER_START = F_MEMORY_START + 0x0125
#const F_DICT_ADD_USER_COUNT = F_MEMORY_START + 0x0126

; #const FREE = F_MEMORY_START + 0x0127
#const F_STATUS_COUNT = F_MEMORY_START + 0x0128

#const F_FIND_TOKEN_MSB = F_MEMORY_START + 0x0129
#const F_FIND_TOKEN_LSB = F_MEMORY_START + 0x012A
#const F_FIND_TOKEN_START = F_MEMORY_START + 0x012B
#const F_FIND_TOKEN_COUNT = F_MEMORY_START + 0x012C

#const F_BI_IF_THEN_START = F_MEMORY_START + 0x012D
#const F_BI_IF_ELSE_START = F_MEMORY_START + 0x012E
#const F_BI_IF_DEPTH = F_MEMORY_START + 0x012F

#const F_INPUT_BUFFER_START_LSB = F_MEMORY_START + 0x0130
#const F_INPUT_BUFFER_START_MSB = F_MEMORY_START + 0x0131
; #const FREE = F_MEMORY_START + 0x0132
#const F_DICT_USER_COUNT = F_MEMORY_START + 0x0133

#const F_ERROR_MSG_LSB = F_MEMORY_START + 0x0134
#const F_ERROR_MSG_MSB = F_MEMORY_START + 0x0135

; DO .. LOOP 
#const F_DO_LOOP_COUNT = F_MEMORY_START + 0x0136

; BEGIN .. UNTIL 
#const F_BEGIN_UNTIL_COUNT = F_MEMORY_START + 0x0137

; IF .. THEN 
#const F_IF_THEN_COUNT = F_MEMORY_START + 0x0138

#const F_CMP_TOKEN_MSB = F_MEMORY_START + 0x0139
#const F_CMP_TOKEN_LSB = F_MEMORY_START + 0x013A
#const F_CMP_CURRENT_CHAR = F_MEMORY_START + 0x013B

#const F_DICT_ADD_USER_DEF_TYPE = F_MEMORY_START + 0x013C  
#const F_DICT_ADD_USER_DEF_VALUE = F_MEMORY_START + 0x013D

#const F_DICT_EXEC_USER_LSB = F_MEMORY_START + 0x013E
#const F_DICT_EXEC_USER_MSB = F_MEMORY_START + 0x013F

#const F_DICT_CACHE_START_LSB = F_MEMORY_START + 0x0140
#const F_DICT_CACHE_START_MSB = F_MEMORY_START + 0x0141
#const F_DICT_CACHE_TYPE = F_MEMORY_START + 0x0142
#const F_LAST_ALLOC_DICT_CACHE_START_LSB = F_MEMORY_START + 0x0143
#const F_LAST_ALLOC_DICT_CACHE_START_MSB = F_MEMORY_START + 0x0144
#const F_DICT_EXEC_USER_CACHE_LSB = F_MEMORY_START + 0x0145
#const F_DICT_EXEC_USER_CACHE_MSB = F_MEMORY_START + 0x0146

; Placing the stack at the end of the variable area
#const F_STACK_START = F_MEMORY_START + 0x0200

; Placing the user dictionary at the end of the stack area 
#const F_DICT_USER_START = F_STACK_START + F_MAX_STACK_SIZE

; Placing the status saving area at the end of the dictionary 
#const F_STATUS_START = F_DICT_USER_START + F_MAX_DICT_SIZE 

; Placing the do-loop stack area at the end of the status
#const F_DO_LOOP_START = F_STATUS_START + F_MAX_STATUS_SIZE

; Placing the begin-until stack area at the end of the do-loop stack area
#const F_BEGIN_UNTIL_START = F_DO_LOOP_START + F_MAX_DO_LOOP_SIZE

; Placing the if-then stack area at the end of the begin-until stack area
#const F_IF_THEN_START = F_BEGIN_UNTIL_START + F_MAX_BEGIN_UNTIL_SIZE

#const F_DICT_CACHE_START = F_IF_THEN_START + F_MAX_IF_THEN_SIZE

; **********************************************************
#once

; **********************************************************
; THE STARTING ADDRESS OF THE FORTH MEMORY
#const F_MEMORY_START = 0xB000
; THE MAX SIZE OF A SINGLE INPUT BUFFER 
#const F_MAX_INPUT_SIZE = 0x400
; THE MAX SIZE OF THE STACK
#const F_MAX_STACK_SIZE = 0x100
; THE MAX SIZE OF THE DICTIONARY (built-in + user)
#const F_MAX_DICT_SIZE = 0x1000 ; 4K
; THE MAX SIZE OF THE STATUS SAVE AREA
#const F_MAX_STATUS_SIZE = 0x400 ; 1K
; THE MAX SIZE OF THE DO-LOOP STACK AREA
#const F_MAX_DO_LOOP_SIZE = 0x100 ; 256 byte
; THE MAX SIZE OF THE BEGIN-UNTIL STACK AREA
#const F_MAX_BEGIN_UNTIL_SIZE = 0x100 ; 256 byte
; THE MAX SIZE OF THE IF-THEN STACK AREA
#const F_MAX_IF_THEN_SIZE = 0x100 ; 256 byte
; **********************************************************

; **********************************************************
; MEMORY OFFSETS
#const F_USER_INPUT_BUFFER_START = F_MEMORY_START

#const F_VARS_START = F_MEMORY_START + F_MAX_INPUT_SIZE

; #const FREE = F_VARS_START + 0x0000
; #const FREE = F_VARS_START + 0x0001
; #const FREE = F_VARS_START + 0x0002
#const F_TOKEN_VALUE = F_VARS_START + 0x0003
#const F_STACK_COUNT = F_VARS_START + 0x0004

#const F_DICT_ADD_USER_LABEL_START_LSB = F_VARS_START + 0x0005
#const F_DICT_ADD_USER_LABEL_START_MSB = F_VARS_START + 0x0006
#const F_DICT_ADD_USER_LABEL_COUNT = F_VARS_START + 0x0007

; #const FREE = F_VARS_START + 0x0008
; #const FREE = F_VARS_START + 0x0009

#const F_TOKEN_START_LSB = F_VARS_START + 0x000A
#const F_TOKEN_START_MSB = F_VARS_START + 0x000B
#const F_TOKEN_COUNT_LSB = F_VARS_START + 0x000C
#const F_TOKEN_COUNT_MSB = F_VARS_START + 0x000D
#const F_TOKEN_POS_LSB   = F_VARS_START + 0x000E
#const F_TOKEN_POS_MSB   = F_VARS_START + 0x000F
#const F_INPUT_BUFFER_PTR_LSB   = F_VARS_START + 0x0010
#const F_INPUT_BUFFER_PTR_MSB   = F_VARS_START + 0x0011
#const F_INPUT_BUFFER_COUNT_LSB = F_VARS_START + 0x0012
#const F_INPUT_BUFFER_COUNT_MSB = F_VARS_START + 0x0013

#const F_BI_IF_THEN_START_LSB = F_VARS_START + 0x0014
#const F_BI_IF_THEN_START_MSB = F_VARS_START + 0x0015
#const F_BI_IF_ELSE_START_LSB = F_VARS_START + 0x0016
#const F_BI_IF_ELSE_START_MSB = F_VARS_START + 0x0017

#const F_DICT_USER_LAST_ADD_LSB = F_VARS_START + 0x001B
#const F_DICT_USER_LAST_ADD_MSB = F_VARS_START + 0x001C

#const F_INPUT_COL_COUNT = F_VARS_START + 0x001D

#const F_DICT_EXEC_BUILT_IN_PTR_PAGE = F_VARS_START + 0x001E
#const F_DICT_EXEC_BUILT_IN_PTR_MSB  = F_VARS_START + 0x001F
#const F_DICT_EXEC_BUILT_IN_PTR_LSB  = F_VARS_START + 0x0020

#const F_EXIT_INTERPRETER_FLAG = F_VARS_START + 0x0021
#const F_EXECUTION_ERROR_FLAG = F_VARS_START + 0x0022
#const F_EXECUTION_ABORT_FLAG = F_VARS_START + 0x0023

#const F_DICT_ADD_USER_START_LSB = F_VARS_START + 0x0024
#const F_DICT_ADD_USER_START_MSB = F_VARS_START + 0x0025

#const F_DICT_ADD_USER_COUNT_LSB = F_VARS_START + 0x0026
#const F_DICT_ADD_USER_COUNT_MSB = F_VARS_START + 0x0027

#const F_STATUS_COUNT = F_VARS_START + 0x0028

#const F_FIND_TOKEN_MSB = F_VARS_START + 0x0029
#const F_FIND_TOKEN_LSB = F_VARS_START + 0x002A
#const F_FIND_TOKEN_START_LIMIT_LSB = F_VARS_START + 0x002B 
#const F_FIND_TOKEN_START_LIMIT_MSB = F_VARS_START + 0x002C 

#const F_BI_IF_THEN_START = F_VARS_START + 0x002D
#const F_BI_IF_ELSE_START = F_VARS_START + 0x002E
#const F_BI_IF_DEPTH = F_VARS_START + 0x002F

#const F_INPUT_BUFFER_START_LSB = F_VARS_START + 0x0030
#const F_INPUT_BUFFER_START_MSB = F_VARS_START + 0x0031
; #const FREE = F_VARS_START + 0x0032
#const F_DICT_USER_COUNT = F_VARS_START + 0x0033

#const F_ERROR_MSG_LSB = F_VARS_START + 0x0034
#const F_ERROR_MSG_MSB = F_VARS_START + 0x0035

; DO .. LOOP 
#const F_DO_LOOP_COUNT = F_VARS_START + 0x0036

; BEGIN .. UNTIL 
#const F_BEGIN_UNTIL_COUNT = F_VARS_START + 0x0037

; IF .. THEN 
#const F_IF_THEN_COUNT = F_VARS_START + 0x0038

#const F_CMP_TOKEN_MSB = F_VARS_START + 0x0039
#const F_CMP_TOKEN_LSB = F_VARS_START + 0x003A
#const F_CMP_CURRENT_CHAR = F_VARS_START + 0x003B

#const F_DICT_ADD_USER_DEF_TYPE = F_VARS_START + 0x003C  
#const F_DICT_ADD_USER_DEF_VALUE = F_VARS_START + 0x003D

#const F_DICT_EXEC_USER_LSB = F_VARS_START + 0x003E
#const F_DICT_EXEC_USER_MSB = F_VARS_START + 0x003F

#const F_DICT_CACHE_START_LSB = F_VARS_START + 0x0040
#const F_DICT_CACHE_START_MSB = F_VARS_START + 0x0041
#const F_DICT_CACHE_TYPE = F_VARS_START + 0x0042
#const F_LAST_ALLOC_DICT_CACHE_START_LSB = F_VARS_START + 0x0043
#const F_LAST_ALLOC_DICT_CACHE_START_MSB = F_VARS_START + 0x0044
#const F_DICT_EXEC_USER_CACHE_LSB = F_VARS_START + 0x0045
#const F_DICT_EXEC_USER_CACHE_MSB = F_VARS_START + 0x0046

#const F_FIND_TOKEN_START_LSB = F_VARS_START + 0x0047
#const F_FIND_TOKEN_START_MSB = F_VARS_START + 0x0048
#const F_FIND_TOKEN_COUNT_LSB = F_VARS_START + 0x0049
#const F_FIND_TOKEN_COUNT_MSB = F_VARS_START + 0x004A

; Placing the stack at the end of the variable area
#const F_STACK_START = F_VARS_START + 0x0100

; Placing the user dictionary at the end of the stack area 
#const F_DICT_USER_START = F_STACK_START + F_MAX_STACK_SIZE

; Placing the status saving area at the end of the dictionary 
#const F_STATUS_START = F_DICT_USER_START + F_MAX_DICT_SIZE 

; Placing the do-loop stack area at the end of the status
#const F_DO_LOOP_START = F_STATUS_START + F_MAX_STATUS_SIZE

; Placing the begin-until stack area at the end of the do-loop stack area
#const F_BEGIN_UNTIL_START = F_DO_LOOP_START + F_MAX_DO_LOOP_SIZE

; Placing the if-then stack area at the end of the begin-until stack area
#const F_IF_THEN_START_LSB = F_BEGIN_UNTIL_START + F_MAX_BEGIN_UNTIL_SIZE
#const F_IF_THEN_START_MSB = F_IF_THEN_START_LSB + F_MAX_IF_THEN_SIZE

; ; Placing the cache area at the end of the if-then stack area
; #const F_DICT_CACHE_START = F_IF_THEN_START_LSB + (F_MAX_IF_THEN_SIZE * 2)

; **********************************************************
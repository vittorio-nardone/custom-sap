; =====================================================
; Brainfuck interpreter for Otto
; =====================================================
; Description:
;   Brainfuck is an esoteric programming language created in 1993 by Swiss student Urban MÃ¼ller.
;   Designed to be extremely minimalistic, the language consists of only eight simple commands, 
;   a data pointer, and an instruction pointer.
;
;   https://en.wikipedia.org/wiki/Brainfuck
;
; Created: 31/12/2024
; Author: Vittorio Nardone
; =====================================================

; Include necessary definitions and symbols
#include "../assembly/ruledef.asm"
#include "../kernel/symbols.asm"

; Define RAM bank starting at 0x8400 with size 0x6C00
#bankdef ram
{
    #addr 0x8400
    #size 0x6C00
    #outp 0
}

#bank ram

    sei                         ; Disable interrupts
    ldd WELCOME_MSG[15:8]      ; Load high byte of welcome message address
    lde WELCOME_MSG[7:0]       ; Load low byte of welcome message address
    jsr ACIA_SEND_STRING       ; Display welcome message

MAIN:
    jsr ACIA_SEND_NEWLINE      ; Print newline
    ldd PROMPT_MSG[15:8]       ; Load high byte of prompt message
    lde PROMPT_MSG[7:0]        ; Load low byte of prompt message
    jsr ACIA_SEND_STRING       ; Display prompt

    lda 0x00                   ; Initialize input buffer counter
    sta INPUT_BUFFER_COUNT

.loop:                         ; Input reading loop
    lda ACIA_CONTROL_STATUS_ADDR                   ; Check serial port status
    bit ACIA_STATUS_REG_RECEIVE_DATA_REGISTER_FULL ; Wait for data
    beq .loop                                      ; If no data, keep waiting
    lda ACIA_RW_DATA_ADDR                         ; Read character from serial port
    jsr ACIA_SEND_CHAR                            ; Echo character back
    tao                                           ; Transfer A to O register
    cmp 0x0D                                      ; Check for Enter key (CR)
    beq RUN                                       ; If Enter, start execution
    ldx INPUT_BUFFER_COUNT                        ; Get current buffer position
    sta INPUT_BUFFER,x                            ; Store character in buffer
    inc INPUT_BUFFER_COUNT                        ; Increment buffer counter
    cpx 0xFF                                      ; Check if buffer is full
    beq RUN                                       ; If full, start execution
    jmp .loop                                     ; Continue reading input

RUN:
    jsr ACIA_SEND_NEWLINE      ; Print newline
    jsr .clean_memory          ; Initialize program memory
    ldx 0x00                   ; Initialize program counter
    stx PRG_POINTER           ; Initialize data pointer

.cmd_loop:                     ; Main interpretation loop
    cpx INPUT_BUFFER_COUNT     ; Check if we've reached end of input
    beq MAIN                   ; If yes, return to main prompt
    lda INPUT_BUFFER,x         ; Load next command
    inx                        ; Increment program counter
    ; Compare with each Brainfuck command
    cmp ">"                    ; Increment pointer command
    beq .cmd_inc_ptr
    cmp "<"                    ; Decrement pointer command
    beq .cmd_dec_ptr
    cmp "+"                    ; Increment value command
    beq .cmd_inc_value
    cmp "-"                    ; Decrement value command
    beq .cmd_dec_value
    cmp "["                    ; Start loop command
    beq .cmd_start_loop
    cmp "]"                    ; End loop command
    beq .cmd_end_loop
    cmp ","                    ; Input command
    beq .cmd_read_char
    cmp "."                    ; Output command
    beq .cmd_print_char
    cmp "q"                    ; Quit command
    bne .cmd_loop              ; If not recognized, ignore and continue
    cli                        ; Enable interrupts
    rts                        ; Return from subroutine

; Command implementations
.cmd_inc_ptr:                  ; Increment data pointer
    inc PRG_POINTER
    jmp .cmd_loop

.cmd_dec_ptr:                  ; Decrement data pointer
    dec PRG_POINTER
    jmp .cmd_loop

.cmd_inc_value:                ; Increment value at pointer
    ldy PRG_POINTER
    lda PRG_MEMORY,y
    clc                        ; Clear carry flag
    adc 0x01                   ; Add 1
    sta PRG_MEMORY,y
    jmp .cmd_loop

.cmd_dec_value:                ; Decrement value at pointer
    ldy PRG_POINTER
    lda PRG_MEMORY,y
    sec                        ; Set carry flag
    sbc 0x01                   ; Subtract 1
    sta PRG_MEMORY,y
    jmp .cmd_loop

.cmd_start_loop:               ; Handle loop start '['
    ldy PRG_POINTER
    lda PRG_MEMORY,y          ; Check value at pointer
    beq .cmd_skip             ; If zero, skip to matching ]
    phx                       ; Push current position for later
    jmp .cmd_loop

.cmd_skip:                     ; Skip loop if value is zero
    jsr .cmd_skip_loop
    jmp .cmd_loop

.cmd_skip_loop:                ; Find matching ] bracket
    cpx INPUT_BUFFER_COUNT
    beq MAIN
    lda INPUT_BUFFER,x
    inx
    cmp "["                    ; Handle nested loops
    beq .cmd_skip_recurse
    cmp "]"
    bne .cmd_skip_loop
    rts

.cmd_skip_recurse:             ; Handle nested loop skipping
    jsr .cmd_skip_loop
    jmp .cmd_skip_loop

.cmd_end_loop:                 ; Handle loop end ']'
    plx                        ; Restore position from start of loop
    dex                        ; Go back one to reprocess [
    jmp .cmd_loop

.cmd_read_char:                ; Read input character
    lda ACIA_CONTROL_STATUS_ADDR                   ; Check serial status
    bit ACIA_STATUS_REG_RECEIVE_DATA_REGISTER_FULL ; Wait for input
    beq .cmd_read_char
    lda ACIA_RW_DATA_ADDR      ; Read character
    ldy PRG_POINTER
    sta PRG_MEMORY,y           ; Store in memory
    jmp .cmd_loop

.cmd_print_char:               ; Output character
    ldy PRG_POINTER
    lda PRG_MEMORY,y  
    jsr ACIA_SEND_CHAR         ; Send to serial port
    jmp .cmd_loop  

.clean_memory:                 ; Initialize program memory to zeros
    lda 0x00
    ldx 0x00
.clean_memory_loop:
    sta PRG_MEMORY,x
    inx
    bne .clean_memory_loop
    rts

; Message section
WELCOME_MSG:                   ; Welcome message text
    #d 0x0A, 0x0D             
    #d "Welcome to Brainfuck interpreter for Otto", 0x0A, 0x0D
    #d 0x0A, 0x0D
    #d "Valid commands:", 0x0A, 0x0D
    #d "   >	increment pointer", 0x0A, 0x0D
    #d "   <	decrement pointer", 0x0A, 0x0D
    #d "   +	increment value at pointer", 0x0A, 0x0D
    #d "   -	decrement value at pointer", 0x0A, 0x0D
    #d "   [	begin loop (continues while value at pointer is non-zero)", 0x0A, 0x0D
    #d "   ]	end loop", 0x0A, 0x0D
    #d "   ,	read one character from input into value at pointer", 0x0A, 0x0D
    #d "   .	print value at pointer to output as a character", 0x0A, 0x0D
    #d "   q    quit interpreter", 0x0A, 0x0D
    #d "   Any other characters are ignored", 0x0A, 0x0D
    #d "More info: https://en.wikipedia.org/wiki/Brainfuck", 0x0A, 0x0D
    #d 0x00    

PROMPT_MSG:                    ; Prompt message text
    #d "Ready: write your code and press ENTER", 0x0A, 0x0D, 0x00

; Data section
; Program buffers and variables
INPUT_BUFFER:                  ; Buffer for storing input program (256 bytes)
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

INPUT_BUFFER_COUNT:            ; Counter for characters in input buffer
    #d 0x00

PRG_MEMORY:                    ; Program memory space (256 bytes)
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    #d 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

PRG_POINTER:                   ; Program memory pointer
    #d 0x00